#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "my_intset.h"
#include "malloc.h"
#include "endianconv.h"

/*
 * intset 的编码方式
 */
#define INTSET_ENC_INT16 (sizeof(int16_t))
#define INTSET_ENC_INT32 (sizeof(int32_t))
#define INTSET_ENC_INT64 (sizeof(int64_t))

 /*返回适用于传入值 v 的编码方式
  *
  * T = O(1)
  */
static uint8_t _intsetValueEncoding(int64_t v) {
	if (v < INT32_MIN || v > INT32_MAX)
		return INTSET_ENC_INT64;
	else if (v < INT16_MIN || v > INT16_MAX)
		return INTSET_ENC_INT32;
	else
		return INTSET_ENC_INT16;
}

/* 调整整数集合的内存空间大小
 *
 * 如果调整后的大小要比集合原来的大小要大，
 * 那么集合中原有元素的值不会被改变。
 *
 * 返回值：调整大小后的整数集合
 *
 * T = O(N)
 */
static intset *intsetResize(intset *is, uint32_t len) {

	// 计算数组的空间大小
	uint32_t size = len * intrev32ifbe(is->encoding);

	// 根据空间大小，重新分配空间
	// 注意这里使用的是 zrealloc ，
	// 所以如果新空间大小比原来的空间大小要大，
	// 那么数组原有的数据会被保留
	is = (intset *)realloc(is, sizeof(intset) + size);

	return is;
}

/* 根据集合的编码方式，将底层数组在 pos 位置上的值设为 value 。
 *
 * T = O(1)
 */
static void _intsetSet(intset *is, int pos, int64_t value) {

	// 取出集合的编码方式
	uint32_t encoding = intrev32ifbe(is->encoding);

	// 根据编码 ((Enc_t*)is->contents) 将数组转换回正确的类型
	// 然后 ((Enc_t*)is->contents)[pos] 定位到数组索引上
	// 接着 ((Enc_t*)is->contents)[pos] = value 将值赋给数组
	// 最后， ((Enc_t*)is->contents)+pos 定位到刚刚设置的新值上 
	// 如果有需要的话， memrevEncifbe 将对值进行大小端转换
	if (encoding == INTSET_ENC_INT64) {
		((int64_t*)is->contents)[pos] = value;
		memrev64ifbe(((int64_t*)is->contents) + pos);
	}
	else if (encoding == INTSET_ENC_INT32) {
		((int32_t*)is->contents)[pos] = value;
		memrev32ifbe(((int32_t*)is->contents) + pos);
	}
	else {
		((int16_t*)is->contents)[pos] = value;
		memrev16ifbe(((int16_t*)is->contents) + pos);
	}
}

/* 根据给定的编码方式 enc ，返回集合的底层数组在 pos 索引上的元素。
 *
 * T = O(1)
 */
static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) {
	int64_t v64;
	int32_t v32;
	int16_t v16;

	// ((ENCODING*)is->contents) 首先将数组转换回被编码的类型
	// 然后 ((ENCODING*)is->contents)+pos 计算出元素在数组中的正确位置
	// 之后 member(&vEnc, ..., sizeof(vEnc)) 再从数组中拷贝出正确数量的字节
	// 如果有需要的话， memrevEncifbe(&vEnc) 会对拷贝出的字节进行大小端转换
	// 最后将值返回
	if (enc == INTSET_ENC_INT64) {
		memcpy(&v64, ((int64_t*)is->contents) + pos, sizeof(v64));
		memrev64ifbe(&v64);
		return v64;
	}
	else if (enc == INTSET_ENC_INT32) {
		memcpy(&v32, ((int32_t*)is->contents) + pos, sizeof(v32));
		memrev32ifbe(&v32);
		return v32;
	}
	else {
		memcpy(&v16, ((int16_t*)is->contents) + pos, sizeof(v16));
		memrev16ifbe(&v16);
		return v16;
	}
}

/* 根据值 value 所使用的编码方式，对整数集合的编码进行升级，
 * 并将值 value 添加到升级后的整数集合中。
 *
 * 返回值：添加新元素之后的整数集合
 *
 * T = O(N)
 */
static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {

	// 当前的编码方式
	uint8_t curenc = intrev32ifbe(is->encoding);

	// 新值所需的编码方式
	uint8_t newenc = _intsetValueEncoding(value);

	// 当前集合的元素数量
	int length = intrev32ifbe(is->length);

	// 根据 value 的值，决定是将它添加到底层数组的最前端还是最后端
	// 注意，因为 value 的编码比集合原有的其他元素的编码都要大
	// 所以 value 要么大于集合中的所有元素，要么小于集合中的所有元素
	// 因此，value 只能添加到底层数组的最前端或最后端
	int prepend = value < 0 ? 1 : 0;

	// 更新集合的编码方式
	is->encoding = intrev32ifbe(newenc);
	// 根据新编码对集合（的底层数组）进行空间调整
	// T = O(N)
	is = intsetResize(is, intrev32ifbe(is->length) + 1);

	 // 根据集合原来的编码方式，从底层数组中取出集合元素
	 // 然后再将元素以新编码的方式添加到集合中
	 // 当完成了这个步骤之后，集合中所有原有的元素就完成了从旧编码到新编码的转换
	 // 因为新分配的空间都放在数组的后端，所以程序先从后端向前端移动元素
	 // 举个例子，假设原来有 curenc 编码的三个元素，它们在数组中排列如下：
	 // | x | y | z | 
	 // 当程序对数组进行重分配之后，数组就被扩容了（符号 ？ 表示未使用的内存）：
	 // | x | y | z | ? |   ?   |   ?   |
	 // 这时程序从数组后端开始，重新插入元素：
	 // | x | y | z | ? |   z   |   ?   |
	 // | x | y |   y   |   z   |   ?   |
	 // |   x   |   y   |   z   |   ?   |
	 // 最后，程序可以将新元素添加到最后 ？ 号标示的位置中：
	 // |   x   |   y   |   z   |  new  |
	 // 上面演示的是新元素比原来的所有元素都大的情况，也即是 prepend == 0
	 // 当新元素比原来的所有元素都小时（prepend == 1），调整的过程如下：
	 // | x | y | z | ? |   ?   |   ?   |
	 // | x | y | z | ? |   ?   |   z   |
	 // | x | y | z | ? |   y   |   z   |
	 // | x | y |   x   |   y   |   z   |
	 // 当添加新值时，原本的 | x | y | 的数据将被新值代替
	 // |  new  |   x   |   y   |   z   |
	 // T = O(N)
	while (length--)
		_intsetSet(is, length + prepend, _intsetGetEncoded(is, length, curenc));

	/* Set the value at the beginning or the end. */
	// 设置新值，根据 prepend 的值来决定是添加到数组头还是数组尾
	if (prepend)
		_intsetSet(is, 0, value);
	else
		_intsetSet(is, intrev32ifbe(is->length), value);

	// 更新整数集合的元素数量
	is->length = intrev32ifbe(intrev32ifbe(is->length) + 1);

	return is;
}

/* 
创建并返回一个新的空整数集合
 *
 * T = O(1)
 */
intset *intsetNew(void) {

	// 为整数集合结构分配空间
	intset *is = (intset *)malloc(sizeof(intset));

	// 设置初始编码
	is->encoding = intrev32ifbe(INTSET_ENC_INT16);

	// 初始化元素数量
	is->length = 0;

	return is;
}

/* 尝试将元素 value 添加到整数集合中。
 *
 * *success 的值指示添加是否成功：
 * - 如果添加成功，那么将 *success 的值设为 1 。
 * - 因为元素已存在而造成添加失败时，将 *success 的值设为 0 。
 *
 * T = O(N)
 */
intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {

	// 计算编码 value 所需的长度
	uint8_t valenc = _intsetValueEncoding(value);
	uint32_t pos;

	// 默认设置插入为成功
	if (success) *success = 1;

	 // 如果 value 的编码比整数集合现在的编码要大
	 // 那么表示 value 必然可以添加到整数集合中
	 // 并且整数集合需要对自身进行升级，才能满足 value 所需的编码
	if (valenc > intrev32ifbe(is->encoding)) {
		// T = O(N)
		return intsetUpgradeAndAdd(is, value);
	}
	else {
		// 运行到这里，表示整数集合现有的编码方式适用于 value

		/* Abort if the value is already present in the set.
		 * This call will populate "pos" with the right position to insert
		 * the value when it cannot be found. */
		 // 在整数集合中查找 value ，看他是否存在：
		 // - 如果存在，那么将 *success 设置为 0 ，并返回未经改动的整数集合
		 // - 如果不存在，那么可以插入 value 的位置将被保存到 pos 指针中
		 //   等待后续程序使用
		if (intsetSearch(is, value, &pos)) {
			if (success) *success = 0;
			return is;
		}

		// 运行到这里，表示 value 不存在于集合中
		// 程序需要将 value 添加到整数集合中

		// 为 value 在集合中分配空间
		is = intsetResize(is, intrev32ifbe(is->length) + 1);
		// 如果新元素不是被添加到底层数组的末尾
		// 那么需要对现有元素的数据进行移动，空出 pos 上的位置，用于设置新值
		// 举个例子
		// 如果数组为：
		// | x | y | z | ? |
		//     |<----->|
		// 而新元素 n 的 pos 为 1 ，那么数组将移动 y 和 z 两个元素
		// | x | y | y | z |
		//         |<----->|
		// 这样就可以将新元素设置到 pos 上了：
		// | x | n | y | z |
		// T = O(N)
		if (pos < intrev32ifbe(is->length)) intsetMoveTail(is, pos, pos + 1);
	}

	// 将新值设置到底层数组的指定位置中
	_intsetSet(is, pos, value);

	// 增一集合元素数量的计数器
	is->length = intrev32ifbe(intrev32ifbe(is->length) + 1);

	// 返回添加新元素后的整数集合
	return is;
}